}
#list of plot objects
plot_list <- list() #list to store plots
for(i in 1:length(unique(data$ImageId))){
tmp <- data %>% filter(ImageId == unique(data$ImageId)[i])
plot_list[[i]] <- ggplot(tmp, aes_string(x=marker)) +
geom_density(color="darkblue", fill="lightblue") + ggtitle(unique(data$ImageId)[i])
}
#plot
n <- length(plot_list)
nCol <- floor(sqrt(n))
plot <- do.call("grid.arrange", c(plot_list, ncol=nCol))
#save plot
dir.create(file.path(output_location, "density_plots"), showWarnings = FALSE) #make directory if not found
ggsave(file=paste(output_location,"/density_plots/test_multiple_images_1_marker_density.png",sep=""), plot=plot, width=10, height=8)
dev.off() #clear plotting space
# plot density plot for multiple images for multiple markers
#possible markers to select
markers <- names(mydata[[1]])
markers
#select markers for plotting 1 image with multiple markers (will take a while depending on number of images) *needs improvement when # of cells increases
#marker selected *Marker must be present for each image
marker <- c("Ecadherin","Actin555","FOXP3","CD45")
for(i in 1:length(mydata)){
if(i == 1){
data <- mydata[[i]] %>% select("ImageId",marker)
}
else{
tmp <- mydata[[i]] %>% select("ImageId",marker)
data <- rbind(data,tmp)
}
}
#reorganize data for plotting
data <- data %>% gather(key="Marker",value="Expression",-ImageId)
#list of plot objects
plot_list <- list() #list to store plots
for(i in 1:length(unique(data$ImageId))){
tmp <- data %>% filter(ImageId == unique(data$ImageId)[i])
plot_list[[i]] <- ggplot(tmp, aes(x=Expression,fill=Marker)) +
geom_density(alpha=0.4) + ggtitle(unique(data$ImageId)[i])
}
#plot
n <- length(plot_list)
nCol <- floor(sqrt(n))
plot <- do.call("grid.arrange", c(plot_list, ncol=nCol))
#save plot
dir.create(file.path(output_location, "density_plots"), showWarnings = FALSE) #make directory if not found
ggsave(file=paste(output_location,"/density_plots/test_multiple_images__multiple_markers_density.png",sep=""), plot=plot, width=10, height=8)
dev.off() #clear plotting space
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[1]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#store output
celltype_output<-list
i=1
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(CellId,markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- IMAAP_data$CellId
#drop cell Id
IMAAP_data <- IMAAP_data %>% select(markers)
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#assign cell type as column
#mydata[[i]]$cell_type <- annotate_the_cells[[3]] #doesn't preserve index
#Save Cell Type Call assign cell type as column
#celltype_output[[i]] <- merge(as.data.frame(CellId),annotate_the_cells[[3]])
#test <- merge(as.data.frame(CellId),annotate_the_cells[[3]])
#merge
#mydata[[i]]$cell_type <- annotate_the_cells[[3]] #doesn't preserve index
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellType <- CellId
celltype_output[[i]] <- output
i
celltype_output[i] <- output
#store output
celltype_output<-list()
celltype_output[[i]] <- output
celltype_output
output <- annotate_the_cells[[3]]
output$CellId <- CellId
head(output)
IMAAP_data$CellId
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(CellId,markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- IMAAP_data$CellId
CellId
IMAAP_data
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(CellId,markers)
IMAAP_data
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
#keep Cell Id
CellId <- nrows(IMAAP_data)
#keep Cell Id
CellId <- row.names(IMAAP_data)
CellId
#keep Cell Id
CellId <- as.integar(row.names(IMAAP_data))
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
CellId
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
head(output)
celltype_output[[i]] <- output
celltype_output
i2=
celltype_output[[i]] <- output
i=2
celltype_output[[i]] <- output
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[1]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#store output
celltype_output<-list()
#careful running all of this on your entire dataset as it will take a while
for(i in 1:length(mydata)){
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
celltype_output[[i]] <- output
}
i
markers
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[2]])
markers
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[2]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#store output
celltype_output<-list()
#careful running all of this on your entire dataset as it will take a while
for(i in 1:length(mydata)){
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[2]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
celltype_output[[i]] <- output
}
i
#store output
celltype_output<-list()
#careful running all of this on your entire dataset as it will take a while
for(i in 1:length(mydata)){
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
celltype_output[[i]] <- output
}
#store output
celltype_output<-list()
#careful running all of this on your entire dataset as it will take a while
for(i in 1:length(mydata)){
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
output$ImageId <- unique(mydata[[i]]$ImageId)
celltype_output[[i]] <- output
}
i=2
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
output <- annotate_the_cells[[3]]
output$CellId <- CellId
output$ImageId <- unique(mydata[[i]]$ImageId)
celltype_output[[i]] <- output
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
#Save Cell Type Call assign cell type as column
View(imaap_model)
i = 3
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
markers
View(annotate_the_cells)
rm(annotate_the_cells)
#identify what marker names to use for analysis
#ideally only include your research/cell-type markers, so exclude DNA and NA channels (but depending on analysis that may not be ideal)
markers <- names(mydata[[i]])
#Display the column names
markers
#Remove markers with DNA in them
markers <- markers[!grepl("DNA",markers)]
#Remove markers with NA + a number in them
markers <- markers[!grepl('NA[0-9]',markers)]
#verify removed
markers
#what columns are marker columns (for this example have two marker sets, so run it slightly different)
#MAKE SURE TO SELECT MARKER COLUMNS that have cell type calling present
#SELECT MARKERS just for cell type to run faster
markers <- markers[3:38]
#verify selecting correct columns
markers
#select for those markers
IMAAP_data <- mydata[[i]] %>% select(markers)
#remove any rows with inifinte
IMAAP_data <- IMAAP_data[is.finite(rowSums(IMAAP_data)),]
#remove any rows with NA present
IMAAP_data <- IMAAP_data %>% drop_na()
#
IMAAP_data <- exp(IMAAP_data)-1
#keep Cell Id
CellId <- as.integer(row.names(IMAAP_data))
#annotate cells by cell type
cell_type_definition <- read.table(file = "../data/cell_type_definition.csv", sep=',', header = T, stringsAsFactors=FALSE)
#NATHAN's FUNCTION
annotate_the_cells <-imaap_annotate_cells_nj (data = IMAAP_data, cheat_sheet = cell_type_definition, SD = 3, sample_name = unique(mydata[[i]]$ImageId))
View(i2)
markers
cell_type_definition
celltype_output[[i]]
i=1
celltype_output[[i]]
unique(celltype_output[[i]]$ImageId)
paste(unique(celltype_output[[i]]$ImageId),"cell_type_calling.csv",sep="")
paste(output_location,"/Cell_Type_Calling",unique(celltype_output[[i]]$ImageId),"_cell_type_calling.csv",sep="")
paste(output_location,"Cell_Type_Calling/",unique(celltype_output[[i]]$ImageId),"_cell_type_calling.csv",sep="")
for(i in 1:length(celltype_output)){
write.csv(celltype_output[[i]],file=paste(output_location,"Cell_Type_Calling/",unique(celltype_output[[i]]$ImageId),"_cell_type_calling.csv",sep=""),sep = ",",
row.names = FALSE)
}
#save results
dir.create(file.path(output_location, "Cell_Type_Calling"), showWarnings = FALSE) #make directory if not found
for(i in 1:length(celltype_output)){
write.csv(celltype_output[[i]],file=paste(output_location,"Cell_Type_Calling/",unique(celltype_output[[i]]$ImageId),"_cell_type_calling.csv",sep=""),sep = ",",
row.names = FALSE)
}
celltype_output[[1]] %>% group_by(cell_type_definition) %>% count()
output
celltype_output[[1]] %>% group_by( Level.4) %>% count()
#
celltype_output[[1]] %>% group_by( Level.4) %>% count() %>% knitr::kable()
